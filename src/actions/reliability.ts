'use server';

import {
  GoogleGenerativeAI,
  HarmCategory,
  HarmBlockThreshold,
} from '@google/generative-ai';
import type {
  Supplier,
  PredictFailureRiskFactorsOutput,
  AnalyzeChartDataOutput,
  AnalyzeChartDataInput,
} from '@/lib/types';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY as string);

const generationConfig = {
  temperature: 0.2,
  topP: 0.8,
  topK: 40,
  maxOutputTokens: 8192,
};

const safetySettings = [
  {
    category: HarmCategory.HARM_CATEGORY_HARASSMENT,
    threshold: HarmBlockThreshold.BLOCK_NONE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
    threshold: HarmBlockThreshold.BLOCK_NONE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
    threshold: HarmBlockThreshold.BLOCK_NONE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
    threshold: HarmBlockThreshold.BLOCK_NONE,
  },
];

const model = genAI.getGenerativeModel({
  model: 'gemini-2.5-flash',
  generationConfig,
  safetySettings,
});

async function runAI<T>(prompt: string): Promise<T | { error: string }> {
  try {
    const result = await model.generateContent(prompt);
    
    if (
      !result.response ||
      !result.response.candidates ||
      result.response.candidates.length === 0
    ) {
      throw new Error('No content generated by AI.');
    }
    
    const responseText = result.response.text();
    if (!responseText) {
      throw new Error('AI returned an empty response.');
    }

    // Clean the response to ensure it's a valid JSON string
    const cleanedText = responseText.replace(/```json/g, '').replace(/```/g, '').trim();

    return JSON.parse(cleanedText) as T;

  } catch (error: any) {
    console.error('Error running AI:', error);
    const errorMessage = error.message || 'An unknown error occurred.';
    return { error: `AI generation failed. Details: ${errorMessage}` };
  }
}

export async function getRiskFactors(
  suppliers: Supplier[]
): Promise<PredictFailureRiskFactorsOutput | { error: string }> {
  if (suppliers.length === 0) {
    return {
      riskFactors: [],
      summary: 'No supplier data available to analyze risk factors.',
    };
  }
  const historicalData = suppliers
    .map(s => `Supplier ${s.name} failure times: ${s.failureTimes.join(', ')}`)
    .join('\n');

  const prompt = `You are an expert reliability engineer. Analyze the following historical failure data to identify the most significant risk factors contributing to failures.

Historical Data:
${historicalData}

Based on this data, provide a brief summary of your analysis and then list the top 3-5 risk factors ranked by importance. The importance should be a number between 0 and 1.

Provide the entire output in a single, valid JSON object with the following structure:
{
  "riskFactors": [ { "factor": "...", "importance": 0.0 } ],
  "summary": "..."
}
Do not include any text or formatting outside of this JSON object.`;

  return runAI<PredictFailureRiskFactorsOutput>(prompt);
}

export async function getChartAnalysis(
  input: AnalyzeChartDataInput
): Promise<AnalyzeChartDataOutput | { error: string }> {
  if (input.suppliers.length === 0) {
    return { error: 'No supplier data to analyze.' };
  }

  const suppliersJson = JSON.stringify(input.suppliers.map(s => ({ name: s.name, beta: s.beta, eta: s.eta })), null, 2);

  const prompt = `You are an expert reliability engineer. Your task is to provide a detailed, comparative analysis of the following suppliers based on their Weibull distribution parameters (Beta and Eta).

Suppliers Data:
${suppliersJson}

Analyze the data and generate a detailed technical explanation for each of the following four reliability charts. For each chart, compare the suppliers and explain what their respective curves signify. Use markdown for formatting, including bolding key terms and using lists where appropriate.

1.  **Reliability Curve R(t):** The probability of a component functioning without failure up to time t.
2.  **Failure Probability F(t):** The probability of a component failing by time t. This is the cumulative distribution function (CDF).
3.  **Probability Density f(t):** The relative likelihood of failure at a specific time t. This is the probability density function (PDF).
4.  **Failure Rate λ(t) (Hazard Function):** The instantaneous rate of failure at time t, given that the component has survived up to t.

Provide the entire output in a single, valid JSON object with the following structure:
{
  "reliability": { "title": "Reliability Curve - R(t)", "analysis": "..." },
  "failureProbability": { "title": "Failure Probability - F(t)", "analysis": "..." },
  "probabilityDensity": { "title": "Probability Density - f(t)", "analysis": "..." },
  "failureRate": { "title": "Failure Rate - λ(t)", "analysis": "..." }
}
Do not include any text or formatting outside of this JSON object.`;

  return runAI<AnalyzeChartDataOutput>(prompt);
}