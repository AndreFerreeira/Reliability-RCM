'use server';

import {
  GoogleGenerativeAI,
  HarmCategory,
  HarmBlockThreshold,
} from '@google/generative-ai';
import type {
  Supplier,
  PredictFailureRiskFactorsOutput,
  AnalyzeChartDataOutput,
  AnalyzeChartDataInput,
} from '@/lib/types';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY as string);

const generationConfig = {
  temperature: 0.2,
  topP: 0.8,
  topK: 40,
  maxOutputTokens: 8192,
};

const safetySettings = [
  {
    category: HarmCategory.HARM_CATEGORY_HARASSMENT,
    threshold: HarmBlockThreshold.BLOCK_NONE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
    threshold: HarmBlockThreshold.BLOCK_NONE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
    threshold: HarmBlockThreshold.BLOCK_NONE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
    threshold: HarmBlockThreshold.BLOCK_NONE,
  },
];

const model = genAI.getGenerativeModel({
  model: 'gemini-2.5-flash',
  generationConfig,
  safetySettings,
});

async function runAI<T>(prompt: string): Promise<T | { error: string }> {
  try {
    const result = await model.generateContent(prompt);
    
    if (
      !result.response ||
      !result.response.candidates ||
      result.response.candidates.length === 0
    ) {
      throw new Error('No content generated by AI.');
    }
    
    const responseText = result.response.text();
    if (!responseText) {
      throw new Error('AI returned an empty response.');
    }

    // Clean the response to ensure it's a valid JSON string
    const cleanedText = responseText.replace(/```json/g, '').replace(/```/g, '').trim();

    return JSON.parse(cleanedText) as T;

  } catch (error: any) {
    console.error('Error running AI:', error);
    const errorMessage = error.message || 'An unknown error occurred.';
    return { error: `AI generation failed. Details: ${errorMessage}` };
  }
}

export async function getRiskFactors(
  suppliers: Supplier[]
): Promise<PredictFailureRiskFactorsOutput | { error: string }> {
  if (suppliers.length === 0) {
    return {
      riskFactors: [],
      summary: 'Nenhum dado de fornecedor disponível para analisar os fatores de risco.',
    };
  }
  const historicalData = suppliers
    .map(s => `Fornecedor ${s.name} tempos de falha: ${s.failureTimes.join(', ')}`)
    .join('\n');

  const prompt = `Você é um engenheiro de confiabilidade especialista. Analise os seguintes dados históricos de falha para identificar os fatores de risco mais significativos que contribuem para as falhas.

Dados Históricos:
${historicalData}

Com base nestes dados, forneça um resumo técnico explicando o que os fatores de risco significam neste contexto e como o "percentual de importância" deve ser interpretado. Em seguida, liste os 3-5 principais fatores de risco classificados por importância. A importância deve ser um número entre 0 e 1, onde 1 indica o maior impacto no risco de falha. Se nenhum padrão claro emergir dos dados, retorne uma matriz vazia para "riskFactors".

Forneça a saída inteira em um único objeto JSON válido com a seguinte estrutura:
{
  "riskFactors": [ { "factor": "...", "importance": 0.0 } ],
  "summary": "..."
}
Não inclua nenhum texto ou formatação fora deste objeto JSON.`;

  return runAI<PredictFailureRiskFactorsOutput>(prompt);
}

export async function getChartAnalysis(
  input: AnalyzeChartDataInput
): Promise<AnalyzeChartDataOutput | { error: string }> {
  if (input.suppliers.length === 0) {
    return { error: 'Nenhum dado de fornecedor para analisar.' };
  }

  const suppliersJson = JSON.stringify(input.suppliers.map(s => ({ name: s.name, beta: s.beta, eta: s.eta })), null, 2);

  const prompt = `Você é um engenheiro de confiabilidade especialista. Sua tarefa é fornecer uma análise comparativa detalhada dos seguintes fornecedores com base em seus parâmetros da distribuição de Weibull (Beta e Eta).

Dados dos Fornecedores:
${suppliersJson}

Analise os dados e gere uma explicação técnica detalhada para cada um dos quatro gráficos de confiabilidade a seguir. Para cada gráfico, compare os fornecedores e explique o que suas respectivas curvas significam. Use markdown para formatação, incluindo negrito para termos-chave e listas quando apropriado.

1.  **Curva de Confiabilidade R(t):** A probabilidade de um componente funcionar sem falha até o tempo t.
2.  **Probabilidade de Falha F(t):** A probabilidade de um componente falhar até o tempo t. Esta é a função de distribuição acumulada (FDA).
3.  **Densidade de Probabilidade f(t):** A probabilidade relativa de falha em um tempo específico t. Esta é a função de densidade de probabilidade (FDP).
4.  **Taxa de Falha λ(t) (Função de Risco):** A taxa instantânea de falha no tempo t, dado que o componente sobreviveu até t.

Forneça a saída inteira em um único objeto JSON válido com a seguinte estrutura:
{
  "reliability": { "title": "Curva de Confiabilidade - R(t)", "analysis": "..." },
  "failureProbability": { "title": "Probabilidade de Falha - F(t)", "analysis": "..." },
  "probabilityDensity": { "title": "Densidade de Probabilidade - f(t)", "analysis": "..." },
  "failureRate": { "title": "Taxa de Falha - λ(t)", "analysis": "..." }
}
Não inclua nenhum texto ou formatação fora deste objeto JSON.`;

  return runAI<AnalyzeChartDataOutput>(prompt);
}
